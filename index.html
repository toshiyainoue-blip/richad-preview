<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>リッチアド テスト環境</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      background: #eee;
      font-family: sans-serif;
    }
    #preview {
      width: 375px;
      margin: auto;
      background: #fff;
      border: 1px solid #ccc;
      min-height: 200px;
      overflow: hidden;
    }
  </style>
</head>
<body>

<h3>リッチアド プレビュー</h3>
<div id="preview"></div>

<script>
function alreadyLoadedScript(src) {
  return !!document.querySelector(`script[src="${CSS.escape(src)}"]`);
}
function alreadyLoadedCss(href) {
  return !!document.querySelector(`link[rel="stylesheet"][href="${CSS.escape(href)}"]`);
}

const params = new URLSearchParams(location.search);
const code = params.get("code");

if (code) {
  const html = code; // ← ENCODEURLで渡してるなら基本これでOK
  const container = document.getElementById("preview");
  container.innerHTML = html;

  // ① link[rel=stylesheet] は head に移して確実に効かせる
  const links = Array.from(container.querySelectorAll('link[rel="stylesheet"]'));
  links.forEach(oldLink => {
    const href = oldLink.getAttribute("href");
    if (href && !alreadyLoadedCss(href)) {
      const newLink = document.createElement("link");
      Array.from(oldLink.attributes).forEach(attr => newLink.setAttribute(attr.name, attr.value));
      document.head.appendChild(newLink);
    }
    oldLink.remove();
  });

  const scripts = Array.from(container.querySelectorAll("script"));

  // ② 外部scriptを順番にロード（onload待ち）＋重複読み込み防止
  const loadInOrder = scripts.reduce((p, oldScript) => {
    return p.then(() => new Promise((resolve, reject) => {
      const src = oldScript.getAttribute("src");

      if (src) {
        // 既に同じsrcが読み込まれてるならスキップ
        if (alreadyLoadedScript(src)) {
          oldScript.remove();
          return resolve();
        }

        const newScript = document.createElement("script");
        newScript.async = false;

        Array.from(oldScript.attributes).forEach(attr => {
          newScript.setAttribute(attr.name, attr.value);
        });

        newScript.onload = () => resolve();
        newScript.onerror = () => reject(new Error("Failed to load: " + src));

        document.head.appendChild(newScript);
        oldScript.remove();
      } else {
        // inline script
        const newScript = document.createElement("script");
        newScript.async = false;

        Array.from(oldScript.attributes).forEach(attr => {
          newScript.setAttribute(attr.name, attr.value);
        });

        newScript.textContent = oldScript.textContent;
        oldScript.parentNode.replaceChild(newScript, oldScript);
        resolve();
      }
    }));
  }, Promise.resolve());

  loadInOrder.catch(err => console.error(err));
}
</script>

</body>
</html>
